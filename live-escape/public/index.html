<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Emergency Evacuation System</title>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script type="module">
      import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
      window.OrbitControls = OrbitControls;
      console.log('‚úÖ OrbitControls loaded');
    </script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&family=DM+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Typography */
            font-family: 'Lato', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 15px;
            line-height: 1.6;
            font-weight: 400;

            font-synthesis: none;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;

            /* Orange/Red Color Palette */
            --orange-50: #f7b267;
            --orange-100: #f79d65;
            --orange-300: #f4845f;
            --orange-500: #f27059;
            --orange-900: #f25c54;

            /* Gray Scale */
            --gray-50: #fafafa;
            --gray-100: #f5f5f5;
            --gray-200: #e5e5e5;
            --gray-300: #d4d4d4;
            --gray-400: #a3a3a3;
            --gray-500: #737373;
            --gray-600: #525252;
            --gray-700: #404040;
            --gray-800: #262626;
            --gray-900: #171717;

            /* Semantic Colors */
            --bg-primary: #ffffff;
            --bg-secondary: #fafafa;
            --bg-tertiary: #f5f5f5;

            --border-color: #e5e5e5;
            --border-light: #f5f5f5;

            --text-primary: #171717;
            --text-secondary: #525252;
            --text-tertiary: #a3a3a3;

            /* Shadows */
            --shadow-xs: 0 1px 2px 0 rgba(0, 0, 0, 0.03);
            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.08);

            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;

            /* Spacing */
            --spacing-xs: 12px;
            --spacing-sm: 16px;
            --spacing-md: 24px;
            --spacing-lg: 40px;
            --spacing-xl: 64px;
        }

        * {
            box-sizing: border-box;
            font-family: 'Lato', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }

        body {
            margin: 0;
            padding: var(--spacing-md);
            min-height: 100vh;
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        h1, h2, h3 {
            font-family: 'DM Sans', sans-serif;
            color: var(--text-primary);
            margin: 0;
            letter-spacing: -0.01em;
        }

        /* Cards */
        .card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: var(--spacing-md);
            box-shadow: var(--shadow-xs);
            transition: all 0.2s ease-out;
        }

        .card:hover {
            box-shadow: var(--shadow-sm);
        }

        /* Buttons */
        button {
            padding: 10px 20px;
            font-size: 14px;
            font-weight: 500;
            font-family: inherit;
            border: none;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all 0.2s ease-out;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            justify-content: center;
        }

        .btn-primary {
            background: var(--orange-500);
            color: white;
            box-shadow: var(--shadow-xs);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--orange-900);
            box-shadow: var(--shadow-sm);
        }

        .btn-danger {
            background: var(--orange-900);
            color: white;
            box-shadow: var(--shadow-xs);
        }

        .btn-danger:hover:not(:disabled) {
            background: #d93d3d;
            box-shadow: var(--shadow-sm);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Status Indicator */
        .status-indicator {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .status-ring {
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            border-radius: 50%;
            animation: ping 2s cubic-bezier(0, 0, 0.2, 1) infinite;
        }

        @keyframes ping {
            75%, 100% {
                transform: scale(1.5);
                opacity: 0;
            }
        }

        /* Badges */
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 500;
        }

        .badge-success {
            background: #f0fdf4;
            color: #15803d;
            border: 1px solid #bbf7d0;
        }

        .badge-warning {
            background: #fefce8;
            color: #a16207;
            border: 1px solid #fef08a;
        }

        .badge-danger {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        /* Loading Spinner */
        .loading-spinner {
            width: 2rem;
            height: 2rem;
            border: 3px solid var(--gray-200);
            border-top-color: var(--orange-500);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Video Container */
        #video-container {
            background: var(--gray-900);
            border-radius: var(--radius-lg);
            overflow: hidden;
            aspect-ratio: 16/9;
            position: relative;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: relative;
            z-index: 1;
        }

        /* Result Card */
        .result-card {
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: var(--spacing-sm);
            transition: all 0.2s ease-out;
        }

        .result-card.hazard {
            border-left: 3px solid var(--orange-900);
            background: #fef2f2;
        }

        /* Metric Row */
        .metric-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid var(--border-light);
        }

        .metric-row:last-child {
            border-bottom: none;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--gray-100);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--gray-300);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--gray-400);
        }

        /* Guidance Overlay Animations */
        .guidance-pulse {
            animation: guidancePulse 1s ease-in-out;
        }

        @keyframes guidancePulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .hazard-flash {
            animation: hazardFlash 0.5s ease-in-out 3;
        }

        @keyframes hazardFlash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .fade-in {
            animation: fadeIn 0.3s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Layout Utilities */
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .flex {
            display: flex;
        }

        .flex-col {
            flex-direction: column;
        }

        .items-center {
            align-items: center;
        }

        .justify-between {
            justify-content: space-between;
        }

        .gap-2 { gap: 8px; }
        .gap-3 { gap: 12px; }
        .gap-4 { gap: 16px; }
        .gap-6 { gap: 24px; }

        .grid {
            display: grid;
            gap: var(--spacing-md);
        }

        .grid-2 {
            grid-template-columns: repeat(2, 1fr);
        }

        @media (max-width: 1024px) {
            .grid-2 {
                grid-template-columns: 1fr;
            }
        }

        /* 3D Map Controls */
        .map-control-btn {
            width: 32px;
            height: 24px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease-out;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }

        .map-control-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .map-control-btn.active {
            background: var(--orange-500);
            border-color: var(--orange-500);
            box-shadow: 0 0 8px rgba(242, 112, 89, 0.5);
        }

        .map-control-btn:active {
            transform: translateY(0);
        }
    </style>
</head>
<body>
    <div class="container" style="padding-top: var(--spacing-md);">
        <!-- Header -->
        <div class="card" style="margin-bottom: var(--spacing-md);">
            <div class="flex items-center justify-between">
                <div>
                    <h1 style="font-size: 24px; font-weight: 600; margin-bottom: 4px;">
                        Emergency Evacuation System
                    </h1>
                    <p style="font-size: 14px; color: var(--text-secondary);">Real-time Video Analysis & AI-Powered Guidance</p>
                </div>
                <div class="flex items-center gap-2" style="padding: 8px 16px; background: var(--bg-secondary); border-radius: var(--radius-md); border: 1px solid var(--border-color);">
                    <div style="position: relative;">
                        <div id="connection-ring" class="status-ring" style="border: 2px solid var(--orange-900);"></div>
                        <div id="connection-dot" class="status-indicator" style="width: 8px; height: 8px; border-radius: 50%; background: var(--orange-900);"></div>
                    </div>
                    <span id="connection-text" style="font-size: 13px; font-weight: 500; color: var(--text-secondary);">CONNECTING...</span>
                </div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="card">
            <div style="display: flex; flex-direction: column; gap: var(--spacing-sm);">
                <div id="video-container" class="relative group">
                        <video id="video" autoplay playsinline muted></video>
                        <div class="absolute top-4 left-4 px-4 py-2 rounded-xl text-sm font-bold font-mono backdrop-blur-md flex items-center gap-2"
                             style="background: rgba(0, 0, 0, 0.8); color: white; border: 1px solid rgba(255, 255, 255, 0.1);"
                             id="video-status">
                            <i data-lucide="camera-off" class="w-4 h-4"></i>
                            <span>CAMERA INACTIVE</span>
                        </div>
                        <div class="absolute inset-0 bg-gradient-to-t from-black/50 to-transparent opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none"></div>

                        <!-- 3D Minimap (Bottom-left) - ALWAYS VISIBLE -->
                        <div id="minimap-3d" style="position: absolute; bottom: 16px; left: 16px; width: 280px; height: 280px; border-radius: var(--radius-md); overflow: hidden; background: rgba(0, 0, 0, 0.95); border: 2px solid rgba(255,255,255,0.2); box-shadow: var(--shadow-lg); z-index: 100;">
                            <!-- Three.js renderer will be injected here -->

                            <!-- 3D Minimap Controls -->
                            <div id="map-controls" style="position: absolute; bottom: 0; left: 0; right: 0; height: 36px; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(4px); border-top: 1px solid rgba(255,255,255,0.1); padding: 6px; display: flex; gap: 4px; align-items: center;">
                                <button id="toggle-auto-follow" class="map-control-btn active" title="Auto-follow camera" onclick="toggleAutoFollow()">
                                    <i data-lucide="navigation" style="width: 14px; height: 14px; color: white;"></i>
                                </button>
                                <button id="toggle-route" class="map-control-btn active" title="Show/hide route" onclick="toggleRoute()">
                                    <i data-lucide="route" style="width: 14px; height: 14px; color: white;"></i>
                                </button>
                                <button id="toggle-exits" class="map-control-btn active" title="Show/hide exits" onclick="toggleExits()">
                                    <i data-lucide="door-open" style="width: 14px; height: 14px; color: white;"></i>
                                </button>
                            </div>
                        </div>

                        <!-- Guidance Overlay -->
                        <div id="guidance-overlay" class="absolute inset-0 pointer-events-none" style="display: none; z-index: 200;">

                            <!-- Immediate Action (Top) -->
                            <div id="immediate-action" style="position: absolute; top: 16px; left: 50%; right: auto; transform: translateX(-50%); padding: 12px 20px; border-radius: var(--radius-lg); backdrop-filter: blur(12px); text-align: center; max-width: 400px; width: auto; margin-left: 0; margin-right: 0; background: rgba(255, 255, 255, 0.98); border: 1px solid var(--border-color); box-shadow: var(--shadow-lg); pointer-events: auto; z-index: 250;">
                                <div class="flex items-center justify-center gap-3" style="justify-content: center;">
                                    <i id="action-icon" data-lucide="arrow-up" style="width: 20px; height: 20px; color: var(--orange-500);"></i>
                                    <span id="action-text" style="font-size: 16px; font-weight: 600; color: var(--text-primary);">CONTINUE STRAIGHT</span>
                                </div>
                            </div>

                            <!-- Hazard Warnings (Right side) -->
                            <div id="hazard-warnings" style="position: absolute; top: 70px; right: 16px; display: flex; flex-direction: column; gap: 8px; max-width: 280px;">
                                <!-- Dynamic hazard badges will be inserted here -->
                            </div>

                            <!-- Progress Info (Bottom-right) -->
                            <div id="progress-info" style="position: absolute; bottom: 80px; right: 16px; padding: 12px 16px; border-radius: var(--radius-md); backdrop-filter: blur(12px); background: rgba(255, 255, 255, 0.98); border: 1px solid var(--border-color); box-shadow: var(--shadow-md);">
                                <div style="display: flex; flex-direction: column; gap: 8px;">
                                    <div class="flex items-center gap-2" style="font-size: 13px; font-weight: 500; color: var(--text-primary);">
                                        <i data-lucide="target" style="width: 14px; height: 14px; color: var(--orange-500);"></i>
                                        <span id="distance-text">-- m to EXIT</span>
                                    </div>
                                    <div class="flex items-center gap-2" style="font-size: 13px; font-weight: 500; color: var(--text-primary);">
                                        <i data-lucide="clock" style="width: 14px; height: 14px; color: var(--orange-500);"></i>
                                        <span id="eta-text">ETA: --s</span>
                                    </div>
                                    <div style="width: 100%; height: 6px; background: var(--gray-200); border-radius: 3px; overflow: hidden;">
                                        <div id="progress-bar" style="height: 100%; background: var(--orange-500); border-radius: 3px; transition: width 0.5s ease-out; width: 0%;"></div>
                                    </div>
                                </div>
                            </div>

                            <!-- Success Overlay (Hidden initially) -->
                            <div id="success-overlay" style="position: absolute; inset: 0; display: none; align-items: center; justify-content: center; backdrop-filter: blur(20px); background: rgba(72, 187, 120, 0.95);">
                                <div style="text-align: center; color: white;">
                                    <i data-lucide="check-circle" style="width: 64px; height: 64px; margin: 0 auto 16px;"></i>
                                    <h2 style="font-size: 28px; font-weight: 600; margin-bottom: 8px;">EVACUATION COMPLETE</h2>
                                    <p style="font-size: 16px;">You have reached the exit. You are safe.</p>
                                </div>
                            </div>

                        </div>

                        <!-- GPS & Metadata Display (Top-left) -->
                        <div id="metadata-overlay" class="metadata-panel">
                            <div class="metadata-content">
                                <h3 class="metadata-title">üì° Status</h3>

                                <!-- Device ID -->
                                <div class="metadata-card">
                                    <div class="metadata-label">Device ID</div>
                                    <div id="display-device-id" class="metadata-value-mono">Loading...</div>
                                </div>

                                <!-- GPS Section -->
                                <div class="metadata-card metadata-card-gps">
                                    <div class="metadata-label">üìç GPS</div>
                                    <div id="display-gps-coords" class="metadata-value-mono">Waiting...</div>
                                    <div id="display-gps-accuracy" class="metadata-subtext">Accuracy: --</div>
                                </div>

                                <!-- Observation Count -->
                                <div class="metadata-card metadata-card-obs">
                                    <div class="metadata-label">üíæ Observations</div>
                                    <div id="display-obs-count" class="metadata-obs-count">0</div>
                                </div>

                                <!-- Metadata Section -->
                                <div class="metadata-card metadata-card-indoor">
                                    <div class="metadata-label">üîç Metadata</div>
                                    <div id="display-scene-type" class="metadata-detail"><strong>Scene:</strong> --</div>
                                    <div id="display-text-detected" class="metadata-detail metadata-text-wrap"><strong>Text:</strong> None</div>
                                    <div id="display-landmarks" class="metadata-detail metadata-text-wrap"><strong>Landmarks:</strong> None</div>
                                    <div id="display-lighting" class="metadata-detail"><strong>Lighting:</strong> --</div>
                                </div>
                            </div>
                        </div>

                        <style>
                            /* Desktop styles */
                            .metadata-panel {
                                position: absolute;
                                top: 16px;
                                left: 16px;
                                max-width: 380px;
                                pointer-events: auto;
                                z-index: 100;
                            }

                            .metadata-content {
                                background: rgba(255, 255, 255, 0.98);
                                border: 1px solid var(--border-color);
                                border-radius: var(--radius-md);
                                padding: 16px;
                                box-shadow: var(--shadow-md);
                                backdrop-filter: blur(12px);
                            }

                            .metadata-title {
                                font-size: 14px;
                                font-weight: 600;
                                margin-bottom: 12px;
                                color: var(--text-primary);
                            }

                            .metadata-card {
                                margin-bottom: 12px;
                                padding: 8px;
                                border-radius: 6px;
                            }

                            .metadata-card:last-child {
                                margin-bottom: 0;
                            }

                            .metadata-card {
                                background: #f0f9ff;
                            }

                            .metadata-card-gps {
                                background: #f0fdf4;
                            }

                            .metadata-card-obs {
                                background: #fef3c7;
                            }

                            .metadata-card-indoor {
                                background: #faf5ff;
                            }

                            .metadata-label {
                                font-size: 11px;
                                color: #64748b;
                                margin-bottom: 4px;
                                font-weight: 500;
                            }

                            .metadata-value-mono {
                                font-size: 11px;
                                font-weight: 600;
                                font-family: monospace;
                                word-break: break-all;
                            }

                            #display-device-id {
                                color: #0369a1;
                            }

                            #display-gps-coords {
                                color: #15803d;
                            }

                            .metadata-subtext {
                                font-size: 10px;
                                color: #4ade80;
                                margin-top: 2px;
                            }

                            .metadata-obs-count {
                                font-size: 24px;
                                font-weight: 700;
                                color: #ca8a04;
                            }

                            .metadata-detail {
                                font-size: 11px;
                                color: #7c3aed;
                                margin-bottom: 4px;
                                line-height: 1.4;
                            }

                            .metadata-detail:last-child {
                                margin-bottom: 0;
                            }

                            .metadata-text-wrap {
                                word-break: break-word;
                            }

                            /* Mobile styles */
                            @media (max-width: 768px) {
                                .metadata-panel {
                                    top: 8px;
                                    right: 8px;
                                    left: auto;
                                    max-width: 200px;
                                    width: auto;
                                }

                                .metadata-content {
                                    padding: 8px;
                                    background: rgba(255, 255, 255, 0.92);
                                }

                                .metadata-title {
                                    font-size: 11px;
                                    margin-bottom: 6px;
                                }

                                .metadata-card {
                                    margin-bottom: 6px;
                                    padding: 5px;
                                }

                                .metadata-label {
                                    font-size: 9px;
                                    margin-bottom: 2px;
                                }

                                .metadata-value-mono {
                                    font-size: 9px;
                                }

                                .metadata-subtext {
                                    font-size: 8px;
                                }

                                .metadata-obs-count {
                                    font-size: 16px;
                                }

                                .metadata-detail {
                                    font-size: 9px;
                                    margin-bottom: 2px;
                                }

                                /* Hide analysis overlay on mobile to prevent overlap */
                                #analysis-overlay {
                                    display: none;
                                }

                                /* Center at top and ensure visibility of directional guidance */
                                #immediate-action {
                                    top: 12px !important;
                                    left: 50% !important;
                                    right: auto !important;
                                    transform: translateX(-50%) !important;
                                    max-width: 280px !important;
                                    width: auto !important;
                                    margin: 0 auto !important;
                                    z-index: 250 !important;
                                    padding: 10px 16px !important;
                                    text-align: center !important;
                                    pointer-events: auto !important;
                                }

                                #guidance-overlay {
                                    z-index: 200 !important;
                                }

                                #immediate-action .flex {
                                    justify-content: center !important;
                                }

                                #action-text {
                                    font-size: 18px !important;
                                    font-weight: 700 !important;
                                }

                                #action-icon {
                                    width: 24px !important;
                                    height: 24px !important;
                                }

                                /* Make 3D minimap smaller on mobile */
                                #minimap-3d {
                                    width: 160px !important;
                                    height: 160px !important;
                                    bottom: 8px !important;
                                    left: 8px !important;
                                }

                                #map-controls {
                                    height: 28px !important;
                                    padding: 4px !important;
                                }

                                .map-control-btn {
                                    width: 24px !important;
                                    height: 20px !important;
                                }

                                .map-control-btn i {
                                    width: 12px !important;
                                    height: 12px !important;
                                }
                            }

                            /* Very small phones */
                            @media (max-width: 480px) {
                                .metadata-panel {
                                    top: 4px;
                                    right: 4px;
                                    left: auto;
                                    max-width: 180px;
                                    width: auto;
                                }

                                .metadata-content {
                                    padding: 6px;
                                    background: rgba(255, 255, 255, 0.90);
                                }

                                .metadata-title {
                                    font-size: 10px;
                                    margin-bottom: 4px;
                                }

                                .metadata-card {
                                    margin-bottom: 5px;
                                    padding: 4px;
                                }

                                .metadata-obs-count {
                                    font-size: 14px;
                                }

                                .metadata-label {
                                    font-size: 8px;
                                }

                                .metadata-value-mono {
                                    font-size: 8px;
                                }

                                .metadata-detail {
                                    font-size: 8px;
                                }

                                /* Center directional guidance at top */
                                #immediate-action {
                                    top: 10px !important;
                                    left: 50% !important;
                                    right: auto !important;
                                    transform: translateX(-50%) !important;
                                    max-width: 240px !important;
                                    width: auto !important;
                                    margin: 0 auto !important;
                                    z-index: 250 !important;
                                    padding: 8px 12px !important;
                                    text-align: center !important;
                                    pointer-events: auto !important;
                                }

                                #guidance-overlay {
                                    z-index: 200 !important;
                                }

                                #immediate-action .flex {
                                    justify-content: center !important;
                                }

                                #action-text {
                                    font-size: 16px !important;
                                }

                                #action-icon {
                                    width: 20px !important;
                                    height: 20px !important;
                                }

                                /* Make 3D minimap even smaller */
                                #minimap-3d {
                                    width: 140px !important;
                                    height: 140px !important;
                                    bottom: 6px !important;
                                    left: 6px !important;
                                }

                                #map-controls {
                                    height: 26px !important;
                                    padding: 3px !important;
                                }

                                .map-control-btn {
                                    width: 22px !important;
                                    height: 18px !important;
                                }

                                .map-control-btn i {
                                    width: 11px !important;
                                    height: 11px !important;
                                }
                            }

                            /* Landscape orientation - ensure perfect centering */
                            @media (max-width: 768px) and (orientation: landscape) {
                                #immediate-action {
                                    top: 10px !important;
                                    left: 50% !important;
                                    right: auto !important;
                                    transform: translateX(-50%) !important;
                                    position: absolute !important;
                                    margin: 0 !important;
                                    z-index: 250 !important;
                                    pointer-events: auto !important;
                                }

                                #guidance-overlay {
                                    z-index: 200 !important;
                                }
                            }
                        </style>

                        <!-- Real-Time Analysis Overlay (Top-right) -->
                        <div id="analysis-overlay" style="position: absolute; top: 16px; right: 16px; max-width: 320px; pointer-events: auto;">
                            <div id="analysis-results" style="background: rgba(255, 255, 255, 0.98); border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: var(--spacing-sm); box-shadow: var(--shadow-md); backdrop-filter: blur(12px);">
                                <div class="flex flex-col items-center justify-center" style="padding: var(--spacing-md) 0; text-align: center;">
                                    <div class="loading-spinner" style="margin-bottom: var(--spacing-sm);"></div>
                                    <p style="font-size: 13px; font-weight: 500; color: var(--text-primary); margin-bottom: 4px;">Awaiting Video Stream</p>
                                    <p style="font-size: 11px; color: var(--text-secondary);">Analysis will begin automatically</p>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="grid" style="grid-template-columns: repeat(2, 1fr); gap: 12px;">
                        <button id="start-btn" onclick="startCamera()" class="btn-primary">
                            <i data-lucide="play" style="width: 16px; height: 16px;"></i>
                            START CAMERA
                        </button>
                        <button id="stop-btn" onclick="stopCamera()" disabled class="btn-danger">
                            <i data-lucide="square" style="width: 16px; height: 16px;"></i>
                            STOP CAMERA
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Load 3D Visualization Library (IIFE format) -->
    <script src="./dist/visualization.iife.js"></script>

    <script>
        // Initialize 3D map when DOM is ready
        function init3DMap() {
            console.log('üöÄ Initializing 3D map...');
            console.log('THREE available:', typeof THREE !== 'undefined');
            console.log('LiveEscapeViz available:', typeof LiveEscapeViz !== 'undefined');

            const container = document.getElementById('minimap-3d');
            if (!container) {
                console.error('‚ùå Container minimap-3d not found!');
                return;
            }

            if (typeof THREE === 'undefined') {
                console.error('‚ùå THREE.js not loaded!');
                return;
            }

            if (typeof LiveEscapeViz === 'undefined') {
                console.error('‚ùå LiveEscapeViz not loaded!');
                return;
            }

            try {
                window.map3DViewer = new LiveEscapeViz.Map3DViewer({
                    container: container,
                    buildingDimensions: { width: 50, height: 50 },
                    floorHeight: 3.5
                });

                // Initialize OrbitControls when available
                if (typeof window.OrbitControls !== 'undefined') {
                    window.map3DViewer.initializeControls(window.OrbitControls);
                    console.log('‚úÖ OrbitControls initialized');
                } else {
                    console.warn('‚ö†Ô∏è OrbitControls not loaded yet, retrying...');
                    setTimeout(() => {
                        if (typeof window.OrbitControls !== 'undefined') {
                            window.map3DViewer.initializeControls(window.OrbitControls);
                            console.log('‚úÖ OrbitControls initialized (delayed)');
                        }
                    }, 500);
                }

                window.map3DViewer.start();

                // Set initial user position - Floor 9 (top floor)
                // window.userPosition should already be set, but ensure Floor 9 if not
                const initialPosition = window.userPosition || { x: 0, y: 28, z: 0 }; // Floor 9: y = 8 * 3.5 = 28m
                window.map3DViewer.updateUserPosition(initialPosition);
                console.log('‚úÖ Initial user position set:', initialPosition);
                console.log('   Floor:', Math.floor(initialPosition.y / 3.5) + 1);

                console.log('‚úÖ 3D Map initialized successfully!');

                // Auto-start the demo walk after 2 seconds
                setTimeout(() => {
                    console.log('üöÄ AUTO-STARTING DEMO WALK');
                    window.triggerDemoWalk();
                }, 2000);
            } catch (error) {
                console.error('‚ùå Failed to initialize 3D map:', error);
                console.error('Error details:', error.message);
                console.error('Error stack:', error.stack);
            }
        }

        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init3DMap);
        } else {
            // DOM already loaded, initialize immediately
            init3DMap();
        }

        // 3D Map Control Functions
        window.toggleAutoFollow = function() {
            if (!window.map3DViewer) return;

            const currentState = window.map3DViewer.getAutoFollow();
            const newState = !currentState;
            window.map3DViewer.setAutoFollow(newState);

            const btn = document.getElementById('toggle-auto-follow');
            if (newState) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }

            console.log('Auto-follow:', newState ? 'ON' : 'OFF');
        };

        window.toggleRoute = function() {
            if (!window.map3DViewer) return;

            const currentState = window.map3DViewer.getRouteVisible();
            const newState = !currentState;
            window.map3DViewer.setRouteVisible(newState);

            const btn = document.getElementById('toggle-route');
            if (newState) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }

            console.log('Route visible:', newState ? 'ON' : 'OFF');
        };

        window.toggleExits = function() {
            if (!window.map3DViewer) return;

            const currentState = window.map3DViewer.getExitsVisible();
            const newState = !currentState;
            window.map3DViewer.setExitsVisible(newState);

            const btn = document.getElementById('toggle-exits');
            if (newState) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }

            console.log('Exits visible:', newState ? 'ON' : 'OFF');
        };

        /**
         * Set user position manually (for testing/debugging)
         * This will be replaced by position calibrator integration
         *
         * Example usage:
         *   setUserPosition(10, 1, 15)        // x=10, floor=1, z=15
         *   setUserPosition(-5, 3, 20)        // x=-5, floor=3, z=20
         *
         * @param {number} x - X coordinate
         * @param {number} floor - Floor number (1-9)
         * @param {number} z - Z coordinate
         */
        window.setUserPosition = function(x, floor, z) {
            if (!window.map3DViewer) {
                console.error('‚ùå 3D Map not initialized yet');
                return;
            }

            // Convert floor number to y coordinate (floor * floorHeight)
            const y = floor * 3.5;

            window.userPosition = { x, y, z };
            window.map3DViewer.updateUserPosition(window.userPosition);

            console.log(`‚úÖ User position updated:`, window.userPosition);
            console.log(`   Floor: ${floor}, Coordinates: (${x}, ${y}, ${z})`);
        };

        /**
         * Get current user position
         */
        window.getUserPosition = function() {
            console.log('Current user position:', window.userPosition);
            if (window.userPosition) {
                const floor = Math.round(window.userPosition.y / 3.5);
                console.log(`Floor: ${floor}, Coordinates: (${window.userPosition.x}, ${window.userPosition.y}, ${window.userPosition.z})`);
            }
            return window.userPosition;
        };

        /**
         * Trigger demo walk - start auto-walk with hardcoded evacuation route
         * Call this from console: triggerDemoWalk()
         */
        window.triggerDemoWalk = function() {
            console.log('üö∂ TRIGGERING DEMO WALK');

            // Hardcoded evacuation route - simple version for testing
            const hardcodedRoute = {
                waypoints: [
                    // Starting position: Center of left side, Floor 9
                    { x: -20, y: 28, z: 5, id: 'start', type: 'normal' },

                    // Segment 1: Move STRAIGHT (east)
                    { x: -15, y: 28, z: 5, id: 'straight-1', type: 'normal' },
                    { x: -10, y: 28, z: 5, id: 'straight-2', type: 'normal' },
                    { x: -5, y: 28, z: 5, id: 'straight-3', type: 'normal' },

                    // Segment 2: RIGHT TURN
                    { x: -2, y: 28, z: 6, id: 'right-turn-start', type: 'normal' },
                    { x: 0, y: 28, z: 8, id: 'right-turn-complete', type: 'normal' },

                    // Segment 3: Walk forward
                    { x: 1, y: 28, z: 10, id: 'forward-1', type: 'normal' },
                    { x: 2, y: 28, z: 12, id: 'forward-2', type: 'normal' },

                    // Segment 4: SHARP LEFT TURN
                    { x: 4, y: 28, z: 12, id: 'sharp-left-start', type: 'normal' },
                    { x: 6, y: 28, z: 11, id: 'sharp-left-continue', type: 'normal' },

                    // Segment 5: Approach stairs
                    { x: 8, y: 28, z: 10, id: 'approaching-stairs', type: 'normal' },

                    // Segment 6: Reach stairwell
                    { x: 10, y: 28, z: 10, id: 'at-stairwell', type: 'stairwell' },

                    // Segment 7: Descend through stairwell (Floor 9 ‚Üí Ground)
                    { x: 10, y: 28, z: 10, id: 'stairwell-floor-9', type: 'normal' },
                    { x: 10, y: 24.5, z: 10, id: 'stairwell-floor-8', type: 'normal' },
                    { x: 10, y: 21, z: 10, id: 'stairwell-floor-7', type: 'normal' },
                    { x: 10, y: 17.5, z: 10, id: 'stairwell-floor-6', type: 'normal' },
                    { x: 10, y: 14, z: 10, id: 'stairwell-floor-5', type: 'normal' },
                    { x: 10, y: 10.5, z: 10, id: 'stairwell-floor-4', type: 'normal' },
                    { x: 10, y: 7, z: 10, id: 'stairwell-floor-3', type: 'normal' },
                    { x: 10, y: 3.5, z: 10, id: 'stairwell-floor-2', type: 'normal' },
                    { x: 10, y: 0, z: 10, id: 'stairwell-floor-1', type: 'normal' },

                    // Segment 8: Exit stairwell on ground floor
                    { x: 12, y: 0, z: 12, id: 'exit-stairwell', type: 'normal' },

                    // Segment 9: Move to exit
                    { x: 15, y: 0, z: 15, id: 'along-bottom-1', type: 'normal' },
                    { x: 18, y: 0, z: 18, id: 'along-bottom-2', type: 'normal' },
                    { x: 20, y: 0, z: 20, id: 'along-bottom-3', type: 'normal' },

                    // Final exit
                    { x: 22, y: 0, z: 22, id: 'exit', type: 'exit' }
                ],
                distance: 150,
                estimatedTime: 120,
                hazardWarnings: [],
                computedAt: Date.now()
            };

            // Draw the orange path line on the map
            if (window.map3DViewer) {
                window.map3DViewer.updateRoute(hardcodedRoute);
                console.log('‚úÖ Route drawn (orange line)');
            } else {
                console.error('‚ùå map3DViewer not available!');
                return;
            }

            // Start the walking animation
            startAutoWalk(hardcodedRoute);
            console.log('‚úÖ Character should now be walking along the path!');
        };
    </script>

    <script>
        // GPS Trajectory Tracker (inline version)
        class GPSTrajectoryTracker {
            constructor() {
                this.positionHistory = [];
                this.referenceGPS = null;
                this.buildingStartPosition = { x: 0, y: 0, z: 0 };
                this.currentBuildingPosition = null;
                this.lastHeading = null;
                this.lastSpeed = 0;

                this.config = {
                    POSITION_HISTORY_SIZE: 10,
                    MIN_DISTANCE_FOR_MOVEMENT: 0.5,
                    HEADING_SMOOTHING_WINDOW: 3,
                    MAX_SPEED_THRESHOLD: 5.0,
                    // L-shaped building bounds (Gates Building)
                    // Main wing: 45m wide x 18m deep, Side wing: 15m wide x 35m deep
                    BUILDING_BOUNDS: { minX: -25, maxX: 25, minZ: -10, maxZ: 35 }
                };
            }

            initialize(startX, startY, startZ) {
                this.buildingStartPosition = { x: startX, y: startY, z: startZ };
                this.currentBuildingPosition = { ...this.buildingStartPosition };
                console.log(`üìç GPS Tracker initialized at (${startX}, ${startY}, ${startZ})`);
            }

            addGPSReading(latitude, longitude, accuracy) {
                const reading = {
                    latitude,
                    longitude,
                    accuracy,
                    timestamp: Date.now()
                };

                if (this.referenceGPS === null) {
                    this.referenceGPS = { latitude, longitude };
                    console.log(`üìç Reference GPS set: (${latitude.toFixed(6)}, ${longitude.toFixed(6)})`);
                    return;
                }

                this.positionHistory.push(reading);
                if (this.positionHistory.length > this.config.POSITION_HISTORY_SIZE) {
                    this.positionHistory.shift();
                }

                this.updateBuildingPosition(reading);
                this.updateHeading();
                this.updateSpeed();
            }

            getCurrentBuildingPosition() {
                return this.currentBuildingPosition;
            }

            getHeading() {
                return this.lastHeading;
            }

            getSpeed() {
                return this.lastSpeed;
            }

            updateBuildingPosition(reading) {
                if (!this.referenceGPS) return;

                const distance = this.haversineDistance(
                    this.referenceGPS.latitude,
                    this.referenceGPS.longitude,
                    reading.latitude,
                    reading.longitude
                );

                const bearing = this.calculateBearing(
                    this.referenceGPS.latitude,
                    this.referenceGPS.longitude,
                    reading.latitude,
                    reading.longitude
                );

                const dx = distance * Math.sin(bearing * Math.PI / 180);
                const dz = distance * Math.cos(bearing * Math.PI / 180);

                let newX = this.buildingStartPosition.x + dx;
                let newZ = this.buildingStartPosition.z + dz;

                newX = Math.max(this.config.BUILDING_BOUNDS.minX, Math.min(this.config.BUILDING_BOUNDS.maxX, newX));
                newZ = Math.max(this.config.BUILDING_BOUNDS.minZ, Math.min(this.config.BUILDING_BOUNDS.maxZ, newZ));

                if (this.currentBuildingPosition && this.positionHistory.length >= 2) {
                    const deltaX = newX - this.currentBuildingPosition.x;
                    const deltaZ = newZ - this.currentBuildingPosition.z;
                    const movementDistance = Math.sqrt(deltaX * deltaX + deltaZ * deltaZ);
                    const timeDelta = (reading.timestamp - this.positionHistory[this.positionHistory.length - 2].timestamp) / 1000;
                    const instantSpeed = movementDistance / timeDelta;

                    if (instantSpeed > this.config.MAX_SPEED_THRESHOLD) {
                        console.warn(`‚ö†Ô∏è GPS jump detected (${instantSpeed.toFixed(2)} m/s), ignoring`);
                        return;
                    }
                }

                this.currentBuildingPosition = {
                    x: newX,
                    y: this.buildingStartPosition.y,
                    z: newZ
                };
            }

            updateHeading() {
                const windowSize = Math.min(this.config.HEADING_SMOOTHING_WINDOW, this.positionHistory.length);
                if (windowSize < 2) return;

                const recentReadings = this.positionHistory.slice(-windowSize);
                const bearings = [];

                for (let i = 0; i < recentReadings.length - 1; i++) {
                    const bearing = this.calculateBearing(
                        recentReadings[i].latitude,
                        recentReadings[i].longitude,
                        recentReadings[i + 1].latitude,
                        recentReadings[i + 1].longitude
                    );
                    bearings.push(bearing);
                }

                if (bearings.length === 0) return;

                const avgBearing = this.averageAngles(bearings);

                if (this.lastHeading === null) {
                    this.lastHeading = avgBearing;
                } else {
                    const alpha = 0.3;
                    this.lastHeading = this.lastHeading + alpha * this.angleDifference(avgBearing, this.lastHeading);
                    if (this.lastHeading < 0) this.lastHeading += 360;
                    if (this.lastHeading >= 360) this.lastHeading -= 360;
                }
            }

            updateSpeed() {
                if (this.positionHistory.length < 2) {
                    this.lastSpeed = 0;
                    return;
                }

                const latest = this.positionHistory[this.positionHistory.length - 1];
                const previous = this.positionHistory[this.positionHistory.length - 2];

                const distance = this.haversineDistance(
                    previous.latitude,
                    previous.longitude,
                    latest.latitude,
                    latest.longitude
                );

                const timeDelta = (latest.timestamp - previous.timestamp) / 1000;

                if (timeDelta > 0) {
                    const instantSpeed = distance / timeDelta;
                    const alpha = 0.4;
                    this.lastSpeed = this.lastSpeed + alpha * (instantSpeed - this.lastSpeed);
                }
            }

            haversineDistance(lat1, lon1, lat2, lon2) {
                const R = 6371000;
                const œÜ1 = lat1 * Math.PI / 180;
                const œÜ2 = lat2 * Math.PI / 180;
                const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
                const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

                const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                          Math.cos(œÜ1) * Math.cos(œÜ2) *
                          Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);

                const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

                return R * c;
            }

            calculateBearing(lat1, lon1, lat2, lon2) {
                const œÜ1 = lat1 * Math.PI / 180;
                const œÜ2 = lat2 * Math.PI / 180;
                const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

                const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
                const x = Math.cos(œÜ1) * Math.sin(œÜ2) -
                          Math.sin(œÜ1) * Math.cos(œÜ2) * Math.cos(ŒîŒª);

                const Œ∏ = Math.atan2(y, x);
                return (Œ∏ * 180 / Math.PI + 360) % 360;
            }

            averageAngles(angles) {
                let sinSum = 0;
                let cosSum = 0;

                for (const angle of angles) {
                    const rad = angle * Math.PI / 180;
                    sinSum += Math.sin(rad);
                    cosSum += Math.cos(rad);
                }

                const avgRad = Math.atan2(sinSum / angles.length, cosSum / angles.length);
                return (avgRad * 180 / Math.PI + 360) % 360;
            }

            angleDifference(angle1, angle2) {
                let diff = angle1 - angle2;
                while (diff > 180) diff -= 360;
                while (diff < -180) diff += 360;
                return diff;
            }
        }

        // Initialize GPS tracker
        const gpsTracker = new GPSTrajectoryTracker();
    </script>

    <script>
        // Initialize Lucide icons
        lucide.createIcons();

        // Configuration
        const SERVER_URL = window.location.origin;

        // Generate unique device ID (or get from localStorage)
        let deviceId = localStorage.getItem('device_id');
        if (!deviceId) {
            deviceId = 'device_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('device_id', deviceId);
            console.log('üÜî Generated new device ID:', deviceId);
        } else {
            console.log('üÜî Using existing device ID:', deviceId);
        }
        const USER_ID = deviceId;

        // Display device ID on screen
        setTimeout(() => {
            const displayDeviceId = document.getElementById('display-device-id');
            if (displayDeviceId) {
                displayDeviceId.textContent = deviceId.substring(0, 25) + '...';
            }
        }, 100);

        // State
        let socket = null;
        let visionSession = null;
        let mediaStream = null;
        let resultCount = 0;

        // GPS State
        let gpsWatchId = null;
        let currentGpsData = null;

        // Guidance overlay state
        let guidanceActive = false;
        let lastGuidanceUpdate = 0;
        let lastSpeechTime = 0;

        // User position state - Floor 9, center of left side (as shown in floor plan)
        const START_POSITION = { x: -20, y: 28, z: 5 }; // Center of left side, Floor 9
        window.userPosition = { ...START_POSITION };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AUTO-WALK DEMO - SIMPLE & WORKING VERSION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let autoWalkActive = false;
        let currentRoute = null;
        let currentWaypointIndex = 0;
        let waypointProgress = 0;
        const WALK_SPEED = 3.0; // meters per second - faster for visibility

        // Initialize GPS tracker with starting position
        // Note: First GPS reading will set the reference point (building's GPS location)
        gpsTracker.initialize(START_POSITION.x, START_POSITION.y, START_POSITION.z);

        // 3D Map Viewer (initialized automatically on page load via module script above)

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // AUTO-WALK UPDATE FUNCTION - SIMPLE, CLEAR, WORKING
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function updateAutoWalk(deltaTime) {
            // Exit early if not active or no route
            if (!autoWalkActive || !currentRoute || !currentRoute.waypoints || currentRoute.waypoints.length < 2) {
                return;
            }

            const waypoints = currentRoute.waypoints;
            const totalWaypoints = waypoints.length;

            // Check if we've reached the end - restart from beginning
            if (currentWaypointIndex >= totalWaypoints - 1) {
                console.log('üéØ Reached END! Restarting from beginning...');
                currentWaypointIndex = 0;
                waypointProgress = 0;
                return;
            }

            // Get current and next waypoint
            const currentWaypoint = waypoints[currentWaypointIndex];
            const nextWaypoint = waypoints[currentWaypointIndex + 1];

            // Calculate distance between waypoints
            const dx = nextWaypoint.x - currentWaypoint.x;
            const dy = nextWaypoint.y - currentWaypoint.y;
            const dz = nextWaypoint.z - currentWaypoint.z;
            const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

            // Calculate progress increment for this frame
            const moveDistance = WALK_SPEED * deltaTime;
            const progressIncrement = (distance > 0) ? (moveDistance / distance) : 1.0;

            // Update progress
            waypointProgress += progressIncrement;

            // Check if we've reached the next waypoint
            if (waypointProgress >= 1.0) {
                waypointProgress = 0;
                currentWaypointIndex++;
                console.log(`‚úì Waypoint ${currentWaypointIndex}/${totalWaypoints}`);
                return;
            }

            // Interpolate position between current and next waypoint
            const newX = currentWaypoint.x + (dx * waypointProgress);
            const newY = currentWaypoint.y + (dy * waypointProgress);
            const newZ = currentWaypoint.z + (dz * waypointProgress);

            // Calculate heading (direction of movement)
            const heading = Math.atan2(dx, dz) * (180 / Math.PI);

            // Update position
            window.userPosition = { x: newX, y: newY, z: newZ };

            // Update Three.js character position
            if (window.map3DViewer) {
                window.map3DViewer.updateUserPosition(window.userPosition, heading);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // ANIMATION LOOP - RUNS CONTINUOUSLY
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        let lastAutoWalkTime = performance.now();
        function autoWalkLoop() {
            const now = performance.now();
            const deltaTime = (now - lastAutoWalkTime) / 1000; // Convert to seconds
            lastAutoWalkTime = now;

            // Update auto-walk animation
            updateAutoWalk(deltaTime);

            // Keep looping
            requestAnimationFrame(autoWalkLoop);
        }

        // Start the animation loop immediately
        console.log('üé¨ Animation loop started');
        autoWalkLoop();

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // START AUTO-WALK - ACTIVATES THE ANIMATION
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        function startAutoWalk(route) {
            if (!route || !route.waypoints || route.waypoints.length < 2) {
                console.error('‚ùå Invalid route!');
                return;
            }

            console.log(`üöÄ Starting auto-walk with ${route.waypoints.length} waypoints`);

            // Set the route and reset animation state
            currentRoute = route;
            currentWaypointIndex = 0;
            waypointProgress = 0;
            autoWalkActive = true;

            // Position character at the first waypoint
            window.userPosition = { ...route.waypoints[0] };

            // Calculate initial heading
            const wp1 = route.waypoints[0];
            const wp2 = route.waypoints[1];
            const dx = wp2.x - wp1.x;
            const dz = wp2.z - wp1.z;
            const heading = Math.atan2(dx, dz) * (180 / Math.PI);

            // Update Three.js scene
            if (window.map3DViewer) {
                window.map3DViewer.updateUserPosition(window.userPosition, heading);
                console.log(`‚úÖ Auto-walk ACTIVE - Character will move along path`);
            } else {
                console.error('‚ùå map3DViewer not available!');
            }
        }

        // GPS Tracking Functions
        function startGPSTracking() {
            console.log('üìç Starting GPS tracking...');

            if (!navigator.geolocation) {
                console.error('‚ùå Geolocation API not available');
                const displayCoords = document.getElementById('display-gps-coords');
                if (displayCoords) {
                    displayCoords.textContent = 'GPS not supported';
                    displayCoords.style.color = '#dc2626';
                }
                return;
            }

            const gpsOptions = {
                enableHighAccuracy: true,
                timeout: 15000,
                maximumAge: 0  // Always get fresh position
            };

            gpsWatchId = navigator.geolocation.watchPosition(
                (position) => {
                    const lat = parseFloat(position.coords.latitude.toFixed(8));
                    const lon = parseFloat(position.coords.longitude.toFixed(8));
                    const acc = parseFloat(position.coords.accuracy.toFixed(1));

                    currentGpsData = {
                        latitude: lat,
                        longitude: lon,
                        accuracy: acc,
                        timestamp: new Date().toISOString()
                    };

                    // Update display on screen
                    const displayCoords = document.getElementById('display-gps-coords');
                    const displayAccuracy = document.getElementById('display-gps-accuracy');
                    if (displayCoords) {
                        displayCoords.textContent = `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
                        displayCoords.style.color = '#15803d';
                    }
                    if (displayAccuracy) {
                        displayAccuracy.textContent = `Accuracy: ¬±${acc}m`;
                    }

                    // === NEW GPS TRAJECTORY TRACKING ===
                    // Add GPS reading to tracker
                    gpsTracker.addGPSReading(lat, lon, acc);

                    // Get updated building position from trajectory
                    const newPosition = gpsTracker.getCurrentBuildingPosition();
                    const heading = gpsTracker.getHeading();
                    const speed = gpsTracker.getSpeed();

                    if (newPosition) {
                        // Only update position if auto-walk is not active
                        if (!autoWalkActive) {
                            window.userPosition = newPosition;

                            // Update minimap immediately
                            if (window.map3DViewer) {
                                window.map3DViewer.updateUserPosition(window.userPosition, heading);
                            }
                        }
                    }
                    // === END GPS TRAJECTORY TRACKING ===
                },
                (error) => {
                    console.error('‚ùå GPS ERROR:', error.code, error.message);
                    currentGpsData = null;
                    const displayCoords = document.getElementById('display-gps-coords');
                    if (displayCoords) {
                        displayCoords.textContent = `GPS Error: ${error.message}`;
                        displayCoords.style.color = '#dc2626';
                    }
                },
                gpsOptions
            );

            console.log('‚úÖ GPS watch started with ID:', gpsWatchId);
        }

        function stopGPSTracking() {
            if (gpsWatchId !== null) {
                navigator.geolocation.clearWatch(gpsWatchId);
                gpsWatchId = null;
                currentGpsData = null;
                console.log('üõë GPS tracking stopped');
            }
        }

        // Initialize Socket.IO
        function initSocket() {
            socket = io(SERVER_URL);

            socket.on('connect', () => {
                console.log('‚úÖ Connected to server');
                updateConnectionStatus(true);
                socket.emit('register-user', {
                    userId: USER_ID,
                    position: { x: 0, y: 0, z: 0 }
                });
                // Start GPS tracking when connected
                startGPSTracking();
            });

            socket.on('disconnect', () => {
                console.log('‚ùå Disconnected from server');
                updateConnectionStatus(false);
                stopGPSTracking();
            });

            socket.on('processing-error', (error) => {
                console.error('‚ùå Processing error:', error);
                showError(error.message);
            });

            socket.on('guidance-update', (payload) => {
                console.log('üö∂ Auto-walk started with', payload.route?.waypoints?.length, 'waypoints');
                lastGuidanceUpdate = Date.now();

                // Update 3D scene (map3DViewer is initialized on page load)
                if (window.map3DViewer && payload.route) {
                    // Route visualization
                    if (payload.route.waypoints && payload.route.waypoints.length > 1) {
                        window.map3DViewer.updateRoute(payload.route);

                        // Start auto-walk demo along the path
                        startAutoWalk(payload.route);
                    }

                    // Hazards
                    if (payload.route.hazardWarnings && payload.route.hazardWarnings.length > 0) {
                        window.map3DViewer.clearHazards();
                        const intensityMap = { low: 1, medium: 3, high: 4, critical: 5 };
                        payload.route.hazardWarnings.forEach(hw => {
                            const intensity = intensityMap[hw.severity] || 3;
                            window.map3DViewer.addHazard(hw.location, hw.type, intensity);
                        });
                    }
                }

                // Show overlay if not visible
                if (!guidanceActive) {
                    document.getElementById('guidance-overlay').style.display = 'block';
                    guidanceActive = true;
                }

                // DISABLED: Arrow keys control the immediate action now
                // updateImmediateAction(payload.immediateActions[0]);
                updateProgressInfo(payload.route);
                updateHazardWarnings(payload.route.hazardWarnings);
                speakInstruction(payload.audio);
            });

            socket.on('hazard-alert', (alert) => {
                console.log('‚ö†Ô∏è HAZARD ALERT:', alert);

                // DISABLED: Arrow keys control the immediate action now
                // Flash the hazard warning
                // const actionElement = document.getElementById('immediate-action');
                // actionElement.style.background = 'rgba(242, 92, 84, 0.98)'; // orange-900
                // actionElement.style.borderColor = '#f25c54';
                // actionElement.style.color = 'white';
                // actionElement.classList.add('hazard-flash');

                // DISABLED: Arrow keys control the text now
                // document.getElementById('action-text').textContent = alert.immediateActions[0].description.toUpperCase();

                // Speak immediately
                speakInstruction(alert.audio, true);

                // DISABLED: Arrow keys control the display now
                // Reset style after 3 seconds
                // setTimeout(() => {
                //     actionElement.style.background = 'rgba(255, 255, 255, 0.98)';
                //     actionElement.style.borderColor = 'var(--border-color)';
                //     actionElement.style.color = 'var(--text-primary)';
                //     actionElement.classList.remove('hazard-flash');
                // }, 3000);
            });

            socket.on('evacuation-complete', (data) => {
                console.log('üéâ EVACUATION COMPLETE:', data);

                // Hide guidance overlay
                document.getElementById('guidance-overlay').style.display = 'none';
                guidanceActive = false;

                // Show success overlay
                const successOverlay = document.getElementById('success-overlay');
                successOverlay.style.display = 'flex';
                lucide.createIcons();

                // Speak success message
                speakInstruction({ instruction: data.message, urgency: 'low' });

                // Hide after 5 seconds
                setTimeout(() => {
                    successOverlay.style.display = 'none';
                }, 5000);
            });
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connection-dot');
            const ring = document.getElementById('connection-ring');
            const text = document.getElementById('connection-text');

            if (connected) {
                dot.style.background = '#22c55e';
                ring.style.borderColor = '#22c55e';
                text.textContent = 'CONNECTED';
                text.style.color = 'var(--text-secondary)';
            } else {
                dot.style.background = 'var(--orange-900)';
                ring.style.borderColor = 'var(--orange-900)';
                text.textContent = 'DISCONNECTED';
                text.style.color = 'var(--text-secondary)';
            }
        }

        function updateVideoStatus(icon, text, bgColor = 'rgba(0, 0, 0, 0.8)', textColor = 'white') {
            const videoStatus = document.getElementById('video-status');
            videoStatus.innerHTML = `
                <i data-lucide="${icon}" class="w-4 h-4"></i>
                <span>${text}</span>
            `;
            videoStatus.style.background = bgColor;
            videoStatus.style.color = textColor;
            lucide.createIcons();
        }

        function showError(message) {
            updateVideoStatus('alert-circle', message.toUpperCase(), 'rgba(242, 92, 84, 0.98)', 'white');
        }

        function updateImmediateAction(action) {
            if (!action) return;

            const actionElement = document.getElementById('immediate-action');
            const iconElement = document.getElementById('action-icon');
            const textElement = document.getElementById('action-text');

            // Set icon based on action type and direction
            let iconName = 'arrow-up';
            if (action.type === 'turn') {
                iconName = action.direction === 'left' ? 'corner-up-left' :
                           action.direction === 'right' ? 'corner-up-right' : 'arrow-up';
            } else if (action.type === 'warning') {
                iconName = 'alert-triangle';
            } else if (action.type === 'wait') {
                iconName = 'pause';
            }

            iconElement.setAttribute('data-lucide', iconName);
            textElement.textContent = action.description.toUpperCase();

            // Add pulse animation
            actionElement.classList.remove('guidance-pulse');
            void actionElement.offsetWidth; // Force reflow
            actionElement.classList.add('guidance-pulse');

            // Re-render icons
            lucide.createIcons();
        }

        function updateProgressInfo(route) {
            if (!route) return;

            const distanceText = document.getElementById('distance-text');
            const etaText = document.getElementById('eta-text');
            const progressBar = document.getElementById('progress-bar');

            // Format distance
            const distance = route.totalDistance;
            distanceText.textContent = `${distance.toFixed(1)}m to EXIT`;

            // Format ETA
            const eta = Math.round(route.estimatedTime);
            etaText.textContent = `ETA: ${eta}s`;

            // Update progress bar (assuming 50m max distance for scaling)
            const progress = Math.max(0, 100 - (distance / 50 * 100));
            progressBar.style.width = `${progress}%`;

            // Change color based on proximity using orange palette
            if (distance < 5) {
                progressBar.style.backgroundColor = '#22c55e'; // Green - very close (reached)
            } else if (distance < 15) {
                progressBar.style.backgroundColor = '#f4845f'; // orange-300 - close
            } else {
                progressBar.style.backgroundColor = '#f27059'; // orange-500 - far
            }
        }

        function updateHazardWarnings(warnings) {
            const container = document.getElementById('hazard-warnings');
            container.innerHTML = ''; // Clear existing

            // Show top 3 most severe warnings
            const topWarnings = warnings.slice(0, 3);

            topWarnings.forEach(warning => {
                const badge = document.createElement('div');
                badge.className = 'flex items-center gap-2 fade-in';
                badge.style.padding = '10px 14px';
                badge.style.borderRadius = 'var(--radius-md)';
                badge.style.backdropFilter = 'blur(12px)';
                badge.style.fontSize = '13px';
                badge.style.fontWeight = '500';

                // Style based on severity using new orange/red palette
                let bgColor, borderColor, textColor, iconName;
                switch (warning.severity) {
                    case 'critical':
                        bgColor = 'rgba(242, 92, 84, 0.98)'; // --orange-900
                        borderColor = 'rgba(242, 92, 84, 1)';
                        textColor = 'white';
                        iconName = 'flame';
                        break;
                    case 'high':
                        bgColor = 'rgba(242, 112, 89, 0.98)'; // --orange-500
                        borderColor = 'rgba(242, 112, 89, 1)';
                        textColor = 'white';
                        iconName = 'alert-triangle';
                        break;
                    case 'medium':
                        bgColor = 'rgba(244, 132, 95, 0.98)'; // --orange-300
                        borderColor = 'rgba(244, 132, 95, 1)';
                        textColor = 'white';
                        iconName = 'alert-circle';
                        break;
                    default:
                        bgColor = 'rgba(255, 255, 255, 0.98)';
                        borderColor = 'var(--border-color)';
                        textColor = 'var(--text-primary)';
                        iconName = 'info';
                }

                badge.style.background = bgColor;
                badge.style.border = `1px solid ${borderColor}`;
                badge.style.color = textColor;
                badge.style.boxShadow = 'var(--shadow-sm)';

                badge.innerHTML = `
                    <i data-lucide="${iconName}" style="width: 14px; height: 14px;"></i>
                    <span>${warning.message}</span>
                `;

                container.appendChild(badge);
            });

            lucide.createIcons();
        }

        function updateMinimap(visualization, route) {
            const canvas = document.getElementById('minimap-canvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Scale factor (50m building ‚Üí 140px canvas = 2.8px per meter)
            const scale = 2.8;
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            // Draw grid lines (every 10m)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = -50; i <= 50; i += 10) {
                const offset = i * scale;
                ctx.beginPath();
                ctx.moveTo(centerX + offset, 0);
                ctx.lineTo(centerX + offset, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, centerY + offset);
                ctx.lineTo(canvas.width, centerY + offset);
                ctx.stroke();
            }

            // Draw hazard overlays (orange/red circles)
            visualization.hazardOverlays.forEach(hazard => {
                const area = hazard.area[0]; // Use first corner for center
                const x = centerX + (area.x - 25) * scale;
                const y = centerY - (area.y - 25) * scale; // Invert Y

                ctx.fillStyle = `rgba(242, 92, 84, ${0.3 + hazard.intensity * 0.1})`; // orange-900
                ctx.beginPath();
                ctx.arc(x, y, 10, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw path line (orange dashed)
            if (visualization.pathLine && visualization.pathLine.length > 1) {
                ctx.strokeStyle = '#f27059'; // orange-500
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();

                visualization.pathLine.forEach((point, index) => {
                    const x = centerX + (point.x - 25) * scale;
                    const y = centerY - (point.y - 25) * scale;
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw exit marker (green)
            const exitMarker = visualization.markerPositions.find(m => m.type === 'exit');
            if (exitMarker) {
                const x = centerX + (exitMarker.position.x - 25) * scale;
                const y = centerY - (exitMarker.position.y - 25) * scale;

                ctx.fillStyle = '#22c55e';
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();

                // Draw "EXIT" label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 8px sans-serif';
                ctx.fillText('EXIT', x - 10, y - 10);
            }

            // Draw user position (blue dot with heading indicator)
            ctx.fillStyle = '#3b82f6';
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, Math.PI * 2);
            ctx.fill();

            // Draw heading indicator (small arrow)
            ctx.strokeStyle = '#3b82f6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX, centerY - 10);
            ctx.stroke();
        }

        function speakInstruction(audio, forceImmediate = false) {
            if (!audio || !audio.instruction) return;

            const now = Date.now();

            // Debounce: wait 10 seconds between speech (unless forced)
            if (!forceImmediate && now - lastSpeechTime < 10000) {
                return;
            }

            // Cancel current speech
            if (window.speechSynthesis.speaking) {
                window.speechSynthesis.cancel();
            }

            const utterance = new SpeechSynthesisUtterance(audio.instruction);

            // Adjust voice parameters based on urgency
            switch (audio.urgency) {
                case 'critical':
                    utterance.rate = 1.2;
                    utterance.pitch = 1.2;
                    utterance.volume = 1.0;
                    break;
                case 'high':
                    utterance.rate = 1.0;
                    utterance.pitch = 1.0;
                    utterance.volume = 0.9;
                    break;
                case 'medium':
                case 'low':
                    utterance.rate = 0.9;
                    utterance.pitch = 0.9;
                    utterance.volume = 0.8;
                    break;
            }

            window.speechSynthesis.speak(utterance);
            lastSpeechTime = now;

            console.log('üîä Speaking:', audio.instruction, '(urgency:', audio.urgency + ')');
        }

        window.startCamera = async function() {
            console.log('üé• ========== START CAMERA CLICKED ==========');
            console.log('Device ID:', deviceId);
            console.log('User ID:', USER_ID);
            console.log('Current GPS Data:', currentGpsData);

            const startBtn = document.getElementById('start-btn');
            const stopBtn = document.getElementById('stop-btn');
            const videoElement = document.getElementById('video');

            console.log('Video element found:', !!videoElement);

            try {
                startBtn.disabled = true;
                updateVideoStatus('loader-2', 'REQUESTING ACCESS...', 'rgba(213, 189, 175, 0.95)', 'black');

                console.log('üé• Requesting camera access...');

                // Get camera stream
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });

                console.log('‚úÖ Camera access granted');
                videoElement.srcObject = mediaStream;

                // Wait for video to start playing
                await new Promise((resolve) => {
                    videoElement.onloadedmetadata = () => {
                        videoElement.play().then(resolve);
                    };
                });

                updateVideoStatus('camera', 'CAMERA ACTIVE', 'rgba(34, 197, 94, 0.95)', 'white');
                console.log('‚úÖ Video feed active');

                // Load Overshoot SDK
                console.log('üì¶ Loading Overshoot SDK...');
                updateVideoStatus('loader-2', 'LOADING AI ANALYSIS...', 'rgba(213, 189, 175, 0.95)', 'black');

                let RealtimeVision;
                const cdnUrls = [
                    'https://cdn.jsdelivr.net/npm/@overshoot/sdk@latest/dist/index.js',
                    'https://esm.sh/@overshoot/sdk@latest',
                    'https://unpkg.com/@overshoot/sdk@latest/dist/index.js',
                    'https://unpkg.com/@overshoot/sdk@latest'
                ];

                let lastError = null;
                for (const url of cdnUrls) {
                    try {
                        console.log(`Trying to load from: ${url}`);
                        const module = await import(url);
                        console.log('Module loaded:', module);
                        RealtimeVision = module.RealtimeVision || module.default?.RealtimeVision || module.default;
                        if (RealtimeVision) {
                            console.log('‚úÖ Overshoot SDK loaded successfully from:', url);
                            break;
                        }
                    } catch (importError) {
                        console.warn(`Failed to load from ${url}:`, importError);
                        lastError = importError;
                    }
                }

                if (!RealtimeVision) {
                    console.error('All CDN attempts failed. Last error:', lastError);
                    throw new Error(`Failed to load Overshoot SDK. Error: ${lastError?.message || 'Unknown error'}`);
                }

                console.log('üîß Initializing Overshoot...');

                // Use the video element we already have
                console.log('Video element:', videoElement);
                if (!videoElement) {
                    throw new Error('Video element not found');
                }

                console.log('üîß Creating RealtimeVision instance...');
                console.log('   API URL: https://cluster1.overshoot.ai/api/v0.2');
                console.log('   Video element:', videoElement);
                console.log('   Video dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
                console.log('   Video ready state:', videoElement.readyState);

                visionSession = new RealtimeVision({
                    apiUrl: 'https://cluster1.overshoot.ai/api/v0.2',
                    apiKey: 'ovs_4488f728fc52c4d2ca6f8972c7cc53e3',
                    prompt: `You are a visual perception system for indoor navigation. Your ONLY job is to extract structured observations from the live video feed.

CRITICAL RULES:
1. DO NOT infer the user's location or position in a building
2. DO NOT reference or assume knowledge of floor plans
3. ONLY describe what you directly see in the video
4. Return observations in a structured format

Extract the following information:

1. **Scene Type**: Classify the environment (hallway, room, lobby, stairwell, elevator_area, corridor_intersection, entrance, unknown)

2. **Text Detection**: Find ALL readable text
   - Room numbers (e.g., "312", "Room 401")
   - Floor indicators (e.g., "Floor 3", "3F")
   - Directional signs (e.g., "EXIT ‚Üí", "STAIRS")
   - Safety signage

3. **Landmarks**: Identify physical features
   - Types: door, staircase, elevator, exit_sign, fire_extinguisher, room_number_plaque, elevator_button_panel, emergency_exit_door
   - Direction: left, right, ahead
   - Distance: near (< 2m), mid (2-5m), far (> 5m)

4. **Quality Assessment**:
   - Lighting: good, dim, poor, backlit
   - Motion blur present: yes/no

Return your observations in this format:
Scene: [type]
Text: [list all text with approximate confidence]
Landmarks: [list with direction and distance]
Lighting: [quality]
Motion: [detected/stable]

REMEMBER: You are a SENSOR, not a localizer. Extract observations, not conclusions about position.`,
                    video: videoElement,
                    source: {
                        type: 'camera',
                        cameraFacing: 'environment'
                    },
                    clip_length_seconds: 1.0,
                    delay_seconds: 6.0,
                    fps: 10,
                    sampling_ratio: 0.2,
                    onResult: (result) => {
                        console.log('üîî onResult callback triggered!');
                        handleAnalysisResult(result);
                    },
                    onError: (error) => {
                        console.error('‚ùå Overshoot error callback triggered!');
                        console.error('   Error:', error);
                        showError(`Overshoot error: ${error.message || error}`);
                    }
                });

                console.log('‚úÖ RealtimeVision instance created successfully');
                console.log('   Vision session object:', visionSession);
                console.log('‚ñ∂Ô∏è Starting analysis...');

                try {
                    await visionSession.start();
                    console.log('‚úÖ visionSession.start() completed successfully');

                    stopBtn.disabled = false;
                    updateVideoStatus('eye', 'ANALYZING LIVE', 'rgba(34, 197, 94, 0.95)', 'white');

                    document.getElementById('analysis-results').innerHTML = '';
                    console.log('‚úÖ System active!');
                } catch (startError) {
                    console.error('Failed to start Overshoot session:', startError);
                    throw startError;
                }

            } catch (error) {
                console.error('‚ùå ========== CAMERA START FAILED ==========');
                console.error('Error type:', error.name);
                console.error('Error message:', error.message);
                console.error('Error stack:', error.stack);
                console.error('Full error:', error);

                showError(error.message);
                updateVideoStatus('alert-circle', 'ERROR: ' + error.message, 'rgba(220, 38, 38, 0.95)', 'white');
                startBtn.disabled = false;

                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                    mediaStream = null;
                }
            }
        };

        window.stopCamera = async function() {
            console.log('üõë Stopping camera...');

            if (visionSession) {
                await visionSession.stop();
                visionSession = null;
            }

            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }

            const videoElement = document.getElementById('video');
            videoElement.srcObject = null;

            document.getElementById('start-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
            updateVideoStatus('camera-off', 'CAMERA INACTIVE');

            if (socket) {
                socket.emit('stop-processing', { userId: USER_ID });
            }

            console.log('‚úÖ Camera stopped');
        };

        // Parse Overshoot result (locationDetector format)
        function parseOvershootResult(result) {
            const text = result.result || result.toString();

            const parsed = {
                scene_type: 'unknown',
                text_detected: [],
                landmarks: [],
                lighting_quality: 'unknown',
                motion_blur_detected: false,
                raw_response: text
            };

            try {
                // Extract scene type
                const sceneMatch = text.match(/Scene:\s*(\w+)/i);
                if (sceneMatch) {
                    parsed.scene_type = sceneMatch[1].toLowerCase();
                }

                // Extract text detections
                const textMatch = text.match(/Text:\s*(.+?)(?=\nLandmarks:|Lighting:|Motion:|$)/is);
                if (textMatch) {
                    const textContent = textMatch[1].trim();
                    if (textContent !== '[]' && textContent.toLowerCase() !== 'none' && textContent.length > 0) {
                        const cleanText = textContent.replace(/[\[\]]/g, '');
                        const texts = cleanText.split(',').map(t => t.trim()).filter(t => t.length > 0);
                        parsed.text_detected = texts.map(t => ({
                            text: t,
                            confidence: 0.8,
                            includes_arrow: /‚Üí|‚Üê|‚Üë|‚Üì|->|<-/.test(t)
                        }));
                    }
                }

                // Extract landmarks
                const landmarksMatch = text.match(/Landmarks:\s*(.+?)(?=\nLighting:|Motion:|$)/is);
                if (landmarksMatch) {
                    const cleanLandmarks = landmarksMatch[1].trim().replace(/[\[\]]/g, '').trim();

                    if (cleanLandmarks.toLowerCase() !== 'none' && cleanLandmarks.length > 0) {
                        const landmarkParts = cleanLandmarks.split(',').map(l => l.trim());
                        let currentLandmark = null;

                        for (const part of landmarkParts) {
                            if (part.includes(':')) {
                                if (currentLandmark) parsed.landmarks.push(currentLandmark);
                                const [type, firstAttr] = part.split(':').map(s => s.trim());
                                currentLandmark = {
                                    type: type.toLowerCase(),
                                    direction: 'ahead',
                                    distance: 'mid',
                                    confidence: 0.75
                                };
                                if (firstAttr && ['left', 'right', 'ahead', 'behind'].includes(firstAttr.toLowerCase())) {
                                    currentLandmark.direction = firstAttr.toLowerCase();
                                }
                            } else if (currentLandmark) {
                                const attr = part.toLowerCase().trim();
                                if (['left', 'right', 'ahead', 'behind'].includes(attr)) {
                                    currentLandmark.direction = attr;
                                } else if (['near', 'mid', 'far'].includes(attr)) {
                                    currentLandmark.distance = attr;
                                }
                            }
                        }
                        if (currentLandmark) parsed.landmarks.push(currentLandmark);
                    }
                }

                // Extract lighting
                const lightingMatch = text.match(/Lighting:\s*(\w+)/i);
                if (lightingMatch) {
                    parsed.lighting_quality = lightingMatch[1].toLowerCase();
                }

                // Extract motion
                const motionMatch = text.match(/Motion:\s*(\w+)/i);
                if (motionMatch) {
                    parsed.motion_blur_detected = motionMatch[1].toLowerCase().includes('detect');
                }
            } catch (e) {
                console.error('Error parsing Overshoot result:', e);
            }

            return parsed;
        }

        // Save observation (GPS + metadata)
        async function saveObservation(metadata) {
            if (!currentGpsData) {
                console.warn('‚ö†Ô∏è No GPS data available, skipping observation save');
                const displayCoords = document.getElementById('display-gps-coords');
                if (displayCoords) {
                    displayCoords.textContent = 'GPS not available';
                    displayCoords.style.color = '#dc2626';
                }
                return;
            }

            try {
                const observation = {
                    device_id: deviceId,
                    timestamp: currentGpsData.timestamp,
                    gps_latitude: currentGpsData.latitude,
                    gps_longitude: currentGpsData.longitude,
                    gps_accuracy: currentGpsData.accuracy,
                    metadata: metadata
                };

                const response = await fetch('/save_observation', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(observation)
                });

                if (response.ok) {
                    const data = await response.json();

                    // Update observation count display
                    const displayObsCount = document.getElementById('display-obs-count');
                    if (displayObsCount) {
                        displayObsCount.textContent = data.total_observations;
                        displayObsCount.style.animation = 'pulse 0.5s ease-in-out';
                        setTimeout(() => {
                            displayObsCount.style.animation = '';
                        }, 500);
                    }
                } else {
                    console.error('‚ùå Failed to save observation:', response.statusText);
                }
            } catch (error) {
                console.error('‚ùå Error saving observation:', error);
            }
        }

        function handleAnalysisResult(result) {
            resultCount++;
            console.log('   Result count:', resultCount);

            // Parse indoor localization metadata (locationDetector format)
            const indoorMetadata = parseOvershootResult(result);

            // Update metadata display on screen
            const displaySceneType = document.getElementById('display-scene-type');
            const displayTextDetected = document.getElementById('display-text-detected');
            const displayLandmarks = document.getElementById('display-landmarks');
            const displayLighting = document.getElementById('display-lighting');

            if (displaySceneType) {
                displaySceneType.innerHTML = `<strong>Scene:</strong> ${indoorMetadata.scene_type}`;
            }

            if (displayTextDetected) {
                const textList = indoorMetadata.text_detected.length > 0
                    ? indoorMetadata.text_detected.map(t => t.text).join(', ')
                    : 'None';
                displayTextDetected.innerHTML = `<strong>Text:</strong> ${textList}`;
            }

            if (displayLandmarks) {
                const landmarkList = indoorMetadata.landmarks.length > 0
                    ? indoorMetadata.landmarks.map(l => `${l.type} (${l.direction}, ${l.distance})`).join(', ')
                    : 'None';
                displayLandmarks.innerHTML = `<strong>Landmarks:</strong> ${landmarkList}`;
            }

            if (displayLighting) {
                displayLighting.innerHTML = `<strong>Lighting:</strong> ${indoorMetadata.lighting_quality}`;
            }

            // Save observation with GPS data
            saveObservation(indoorMetadata);

            // Map to emergency format for backward compatibility with live-escape UI
            const analysis = {
                scene_type: indoorMetadata.scene_type,
                text_detected: indoorMetadata.text_detected,
                landmarks: indoorMetadata.landmarks,
                lighting_quality: indoorMetadata.lighting_quality,
                motion_blur_detected: indoorMetadata.motion_blur_detected,
                // Legacy fields for UI compatibility
                obstacles: [],
                hazards: { fire: { present: false }, smoke: { present: false }, water: { present: false } },
                people: { count: 0, density: 'clear' },
                exits: indoorMetadata.landmarks.filter(l => l.type === 'exit_sign' || l.type === 'emergency_exit_door'),
                confidence: 0.85
            };

            displayAnalysisResult(analysis, result);

            if (socket) {
                socket.emit('video-analysis', {
                    userId: USER_ID,
                    analysis,
                    latency: result.total_latency_ms
                });
            }

            const videoStatus = document.getElementById('video-status');
            videoStatus.innerHTML = `
                <i data-lucide="eye" class="w-4 h-4"></i>
                <span>LIVE ‚Ä¢ ${resultCount} results ‚Ä¢ ${result.total_latency_ms}ms</span>
            `;
            lucide.createIcons();
        }

        function displayAnalysisResult(analysis, metadata) {
            const container = document.getElementById('analysis-results');
            const hasHazards = analysis.hazards?.fire?.present ||
                             analysis.hazards?.smoke?.present ||
                             analysis.hazards?.water?.present;

            const timestamp = new Date().toLocaleTimeString('en-US', { hour12: false });
            const confidence = ((analysis.confidence || 0) * 100).toFixed(0);

            // Update in place instead of creating new cards
            container.className = 'result-card' + (hasHazards ? ' hazard' : '');
            container.innerHTML = `
                <div class="flex items-center justify-between mb-3">
                    <span class="text-xs font-mono text-gray-500 flex items-center gap-1">
                        <i data-lucide="clock" class="w-3 h-3"></i>
                        ${timestamp}
                    </span>
                    <span class="badge badge-success text-xs">
                        <i data-lucide="check-circle" class="w-3 h-3"></i>
                        ${confidence}%
                    </span>
                </div>

                ${hasHazards ? '<div class="text-red-600 font-medium text-sm mb-3 flex items-center gap-2"><i data-lucide="alert-triangle" class="w-4 h-4"></i> HAZARDS DETECTED</div>' : ''}

                <div class="space-y-1">
                    <div class="metric-row">
                        <span class="font-medium text-sm text-gray-700 flex items-center gap-2">
                            <i data-lucide="box" class="w-4 h-4 text-gray-600"></i>
                            Obstacles
                        </span>
                        <span class="font-mono text-sm text-gray-900">${analysis.obstacles?.length || 0}</span>
                    </div>

                    <div class="metric-row">
                        <span class="font-medium text-sm text-gray-700 flex items-center gap-2">
                            <i data-lucide="flame" class="w-4 h-4 text-orange-600"></i>
                            Fire
                        </span>
                        <span class="text-sm text-gray-900">
                            ${analysis.hazards?.fire?.present ?
                                `<span class="badge badge-danger text-xs"><i data-lucide="flame" class="w-3 h-3"></i> LVL ${analysis.hazards.fire.intensity}</span>` :
                                '<span class="font-mono text-xs text-gray-500">NONE</span>'}
                        </span>
                    </div>

                    <div class="metric-row">
                        <span class="font-medium text-sm text-gray-700 flex items-center gap-2">
                            <i data-lucide="cloud" class="w-4 h-4 text-gray-600"></i>
                            Smoke
                        </span>
                        <span class="text-sm text-gray-900">
                            ${analysis.hazards?.smoke?.present ?
                                `<span class="badge badge-warning text-xs"><i data-lucide="cloud" class="w-3 h-3"></i> LVL ${analysis.hazards.smoke.density}</span>` :
                                '<span class="font-mono text-xs text-gray-500">NONE</span>'}
                        </span>
                    </div>

                    <div class="metric-row">
                        <span class="font-medium text-sm text-gray-700 flex items-center gap-2">
                            <i data-lucide="droplets" class="w-4 h-4 text-blue-600"></i>
                            Water
                        </span>
                        <span class="text-sm text-gray-900">
                            ${analysis.hazards?.water?.present ?
                                `<span class="badge badge-warning text-xs"><i data-lucide="droplets" class="w-3 h-3"></i> ${analysis.hazards.water.depth.toUpperCase()}</span>` :
                                '<span class="font-mono text-xs text-gray-500">NONE</span>'}
                        </span>
                    </div>

                    <div class="metric-row">
                        <span class="font-medium text-sm text-gray-700 flex items-center gap-2">
                            <i data-lucide="users" class="w-4 h-4 text-gray-600"></i>
                            People
                        </span>
                        <span class="font-mono text-sm text-gray-900">${analysis.people?.count || 0} <span class="text-xs text-gray-500">(${analysis.people?.density || 'unknown'})</span></span>
                    </div>

                    <div class="metric-row">
                        <span class="font-medium text-sm text-gray-700 flex items-center gap-2">
                            <i data-lucide="door-open" class="w-4 h-4 text-green-600"></i>
                            Exits
                        </span>
                        <span class="font-mono text-sm text-gray-900">${(analysis.exits || []).filter(e => e.visible).length} visible</span>
                    </div>

                    <div class="metric-row">
                        <span class="font-medium text-sm text-gray-700 flex items-center gap-2">
                            <i data-lucide="timer" class="w-4 h-4 text-gray-600"></i>
                            Latency
                        </span>
                        <span class="font-mono text-sm text-gray-900">${metadata.total_latency_ms}ms</span>
                    </div>
                </div>
            `;

            // Reinitialize Lucide icons for new content
            lucide.createIcons();
        }

        // Arrow key controls for guidance display
        // This function manages the immediate action display and keeps it persistent
        // until a different arrow key is pressed
        let currentGuidanceState = { icon: 'arrow-up', text: 'CONTINUE STRAIGHT' };

        function setupArrowKeyControls() {
            const actionElement = document.getElementById('immediate-action');
            const textElement = document.getElementById('action-text');
            const guidanceOverlay = document.getElementById('guidance-overlay');

            // Show the guidance overlay
            guidanceOverlay.style.display = 'block';

            // Function to update and persist the action display
            function updateAction(iconName, text) {
                console.log(`üéØ updateAction called - Icon: "${iconName}", Text: "${text}"`);

                // Update the persistent state
                currentGuidanceState.icon = iconName;
                currentGuidanceState.text = text;

                // Update text
                textElement.textContent = text;

                // Get icon element fresh each time
                const iconElement = document.getElementById('action-icon');

                // Completely replace the icon element
                const newIcon = document.createElement('i');
                newIcon.id = 'action-icon';
                newIcon.setAttribute('data-lucide', iconName);
                newIcon.style.width = '20px';
                newIcon.style.height = '20px';
                newIcon.style.color = 'var(--orange-500)';

                // Replace the old icon with the new one
                if (iconElement && iconElement.parentNode) {
                    iconElement.parentNode.replaceChild(newIcon, iconElement);
                }

                // Re-render icons - this recreates the SVG from the data-lucide attribute
                lucide.createIcons();

                // Verify icon was updated
                console.log(`‚úÖ Icon replaced - data-lucide="${newIcon.getAttribute('data-lucide')}"`);

                // Add pulse animation
                actionElement.classList.remove('guidance-pulse');
                void actionElement.offsetWidth; // Force reflow
                actionElement.classList.add('guidance-pulse');
            }

            // Set initial state (straight)
            updateAction('arrow-up', 'CONTINUE STRAIGHT');

            // Handle arrow key presses
            window.addEventListener('keydown', (event) => {
                console.log(`‚å®Ô∏è Key pressed: ${event.key}`);

                // Prevent default scrolling behavior
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(event.key)) {
                    event.preventDefault();
                    console.log(`üéÆ Arrow key detected: ${event.key}`);
                }

                if (event.key === 'ArrowUp') {
                    // Forward/Up arrow ‚Üí Continue Straight
                    updateAction('arrow-up', 'CONTINUE STRAIGHT');
                } else if (event.key === 'ArrowRight') {
                    // Right arrow ‚Üí Turn Right 87 degrees (curved turn arrow)
                    updateAction('corner-up-right', 'TURN RIGHT 87 DEGREES');
                } else if (event.key === 'ArrowLeft') {
                    // Left arrow ‚Üí Turn Left 92 degrees (curved turn arrow)
                    updateAction('corner-up-left', 'TURN LEFT 92 DEGREES');
                } else if (event.key === 'ArrowDown') {
                    // Down arrow ‚Üí U-Turn / Turn Around
                    updateAction('arrow-down', 'TURN AROUND');
                }
            });

            // Expose function to restore state if socket tries to override
            window.forceRestoreGuidanceState = function() {
                updateAction(currentGuidanceState.icon, currentGuidanceState.text);
            };

            console.log('‚úÖ Arrow key controls enabled (‚Üë = straight, ‚Üí = right turn, ‚Üê = left turn, ‚Üì = turn around)');
        }

        // Setup arrow key controls when page loads
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(setupArrowKeyControls, 1000);
        });

        // Initialize
        initSocket();

        // Cleanup
        window.addEventListener('beforeunload', () => {
            if (visionSession) visionSession.stop();
            if (mediaStream) mediaStream.getTracks().forEach(track => track.stop());
        });
    </script>
</body>
</html>
